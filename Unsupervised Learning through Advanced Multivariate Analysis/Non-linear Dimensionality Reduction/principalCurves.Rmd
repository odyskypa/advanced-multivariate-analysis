---
title: "Assigntment 3 - Non-linear dimensionality reduction\n Advanced Multivariate Analysis
  (AMA)"
author: "Joan Oliveras Torra, Odysseas Kyparissis, Louis Tichelman"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 

# Clear plots
if(!is.null(dev.list())) dev.off()

# Clean workspace
rm(list=ls())
require(plot3D)
require(princurve)
if (!require(stops, quietly=TRUE, warn.conflicts=FALSE)){
  install.packages("stops", repos="http://R-Forge.R-project.org",INSTALL_opts="--no-test-load")
}

library(stops)
library(vegan)
```

# PART A: Principal Curves

# 1. Choosing the smoothing parameter in Principal Curves (Hastie and Stuetzle 1989)

We consider the 3-dimensional data set generated by the following code:

```{r data.generation}
t <- seq(-1.5*pi,1.5*pi,l=100)
R<- 1
n<-75
sd.eps <- .15

set.seed(1)
y <- R*sign(t) - R*sign(t)*cos(t/R)
x <- -R*sin(t/R)
z <- (y/(2*R))^2
rt <- sort(runif(n)*3*pi - 1.5*pi)
eps <- rnorm(n)*sd.eps
ry <- R*sign(rt) - (R+eps)*sign(rt)*cos(rt/R)
rx <- -(R+eps)*sin(rt/R)
rz <- (ry/(2*R))^2 + runif(n,min=-2*sd.eps,max=2*sd.eps)
XYZ <- cbind(rx,ry,rz)


lines3D(x, y, z, colvar = NULL, 
         phi = 20, theta = 60, r =sqrt(3), d =3, scale=FALSE,
         col=2,lwd=4,as=1,
         xlim=range(rx),ylim=range(ry),zlim=range(rz))
points3D(rx,ry,rz,col=4,pch=19,cex=.6,add=TRUE)
```

This code is producing a 3D plot that combines both lines and points in a 3D space. In the following list it is explained what each part of the code does:

1.  The code starts by defining a sequence of values for the variable `t`. `t` is generated as a sequence ranging from $-1.5π$ to $1.5π$ with 100 equally spaced points.

2.  `R`, `n`, and `sd.eps` are defined as numeric constants. `R` is set to 1, `n` to 75, and `sd.eps` to 0.15.

3.  The random number generator's seed is set to 1 using `set.seed(1)` for reproducibility.

4.  A series of calculations are performed to generate `x`, `y`, and `z` values. These calculations involve trigonometric functions like `sin` and `cos` applied to `t` and other variables. The specific equations used are a bit complex and involve the signs of `t` and a random error term (`eps`), but they are essentially used to generate 3D coordinates `(x, y, z)` based on the values of `t`.

5.  Another set of random values is generated for `rt` and `eps`. `rt` is generated using `runif(n)*3*pi - 1.5*pi`, and `eps` is generated using `rnorm(n)*sd.eps`. These random values are used in the calculations for `rx`, `ry`, and `rz` and represent the random points around the curve.

6.  `rx`, `ry`, and `rz` are calculated based on the random values and equations similar to those used for `x`, `y`, and `z`. These variables represent another set of 3D coordinates.

7.  The `XYZ` matrix is created by binding `rx`, `ry`, and `rz` into a single matrix.

8.  A 3D line plot is created using the `lines3D` function. It takes the coordinates `x`, `y`, and `z` and plots lines in a 3D space with some specific visual parameters, like color and line width.

9.  Points are added to the plot using the `points3D` function, which takes the coordinates `rx`, `ry`, and `rz` and plots them as points in the same 3D space, with different colors and marker styles.

In summary, this code generates a 3D plot with lines and points in a 3D space. The coordinates for the lines and points are calculated based on trigonometric functions, random values, and some specific equations, resulting in a complex 3D pattern.

### Questions a

In this section, the value of the degrees of freedom ($df$) is chosen by leave-one-out cross-validation (LOOCV). The smoother used by default when calling `principal_curve` method is the `smooth_spline`. However, the degrees of freedom used during the smoothing procedure can be selected by applying LOOCV.

In order to do so, the search of $df$ is restricted to the values of `seq(2, 8, by=1)`. By giving a graphical representation of the principal curve output for the optimal $df$ it is possible to interpret the quality of the results. More specifically:

```{r df.LOOCV}
sum_squared_errors <- c()
for (df in seq(2,8,by=1)){
  errors <- 0
  # leave one out cross validation
  for (point in seq(1:nrow(XYZ))){
    curve <- principal_curve(XYZ[-(point), ],df = df)
    errors <- errors + project_to_curve(matrix(XYZ[point, ], ncol=3), curve$s[curve$ord,])$dist
  }
  sum_squared_errors <- append(sum_squared_errors, errors)
}
```

In order to conclude on which is the best value for the degrees of freedom while fitting the principal curve, we are analyzing the sum of squared errors produced in each LOOCV attempt. To do so, we are making use of the `project_to_curve` method of the `princurve` package, and specifically on the `dist` variable of the result, which represents the sum-of-squared distances from the points to their projections. As it can be seen in the following result, the minimum sum-of-squared error has been achieved for a value of $df=6$.

```{r best.df.principal.curve}
best_df <- seq(2,8,by=1)[which.min(sum_squared_errors)]
best_curve <- principal_curve(XYZ, df = best_df)
best_df
```

## Question b

Once the best value for $df$ is found, a new fit of the principal curve is conducted, and the graphical representation of the curve, together with the random generated data points is taking place in the following plot.

```{r plot.best.curve}
lines3D(best_curve$s[, 1],
        best_curve$s[, 2],
        best_curve$s[, 3], 
        colvar = NULL, phi = 20, theta = 60, r =sqrt(3), d =3, scale=FALSE,
        col=2,lwd=4,as=1,xlim=range(rx),ylim=range(ry),zlim=range(rz))
points3D(rx,ry,rz,col=4,pch=19,cex=.6,add=TRUE)
```

In order to provide, a comparison between the sum-of-squared errors, achieved during the LOOCV procedure the following plot is produced.

```{r SME.vs.df.plot}
plot(seq(2,8,by=1), sum_squared_errors, main="Result of LOOCV", xlab = "degrees of freedom", ylab = "Sum of squared errors of LOOCV")
```

From the result it can be seen that as the degrees of freedom increase the sum-of-squared error is decreasing, until it reaches a certain lower-bound (for $df=6$), and then the occurrence of error is starting to increasing again.

### Question c

In this part of the assignment, the computation of the leave-one-out cross-validation error for $df=50$ is taking place, following by its comparison with the result corresponding to the optimal $df$ value ($6$) found before.

```{r SME.df50}
errors_df50 <- 0
for (point in nrow(XYZ)){
  curve <- principal_curve(XYZ[-(point), ],df = 50)
  errors_df50 <- errors_df50 + project_to_curve(matrix(XYZ[point, ], ncol=3), curve$s)$dist
}
print(paste0("sum or squared errors for df=50: ",errors_df50))
print(paste0("sum or squared errors for df=6: ",min(sum_squared_errors)))
```

Looking at the sum-of-squared error produced when setting the degrees of freedom equal to $50$, it is clear that the squared error of the projections to the fitted line are way smaller compared to the best solution found in Question b. In order to understand better the obtained result the graphical representation of the fitted curved is presented below.

```{r plot.curve.50}
curve_df50 <- principal_curve(XYZ, df = 50)
lines3D(curve_df50$s[, 1],
        curve_df50$s[, 2],
        curve_df50$s[, 3], 
        colvar = NULL, phi = 20, theta = 60, r =sqrt(3), d =3, scale=FALSE,
        col=2,lwd=4,as=1,xlim=range(rx),ylim=range(ry),zlim=range(rz))
points3D(rx,ry,rz,col=4,pch=19,cex=.6,add=TRUE)
```

After observing the fitted curve for $df=50$, it is clear that the preferable choice between the two options is the fitter curve with $df=6$. The principal curve with degree of freedom equal to $50$ is obviously over-fitting. This means that the model captures noise and random fluctuations rather than the underlying pattern in the data. Consequently, the sum-of-squared errors may appear smaller because the model is able to closely follow the data points, even if it means introducing unnecessary complexity. A reason for a so good value of leave-one-out cross-validation error might be because the data set is pretty dense, and an over-fitted curve might always be close to the ground truth and thus return low errors. Additionally, other than in a classical regression setting the principal curve does not give a prediction for an input, from which we compute the error, but instead the computed error is just the distance from a point to the curve. When the curve is very overfitted we get a very "long" "zickzack" curve so the chance that some part of the curve is near to a point is high.


However, using a model with too many degrees of freedom may not generalize well to new data, leading to poor predictive performance. It might result in poor performance when applied to unseen data due to the model's sensitivity to noise and fluctuations in the training data. Consequently, the resulting curve may not provide a meaningful representation of the central trend or shape of the data.

It's always important to find a balance between model complexity and generalizability. A high degree of freedom might indicate that the model is capturing too much noise and might not be able to generalize well to new data. On the other hand, a lower degree of freedom that minimizes the sum-of-squared errors might indicate a more parsimonious model that captures the essential structure of the data without being overly influenced by noise.

# PART B: Local MDS, ISOMAP and t-SNE

In this part of the assignment, the `ZIP number data set` (from the book of Hastie et al.(2009)) is considered. In the following chunk the training data set is being read from the file `zip.train` and only the vectors of pixels corresponding to `ZEROs` are selected.

```{r read.zip.train}
zip.train = read.table("zip.train")
I.0 <- (zip.train[,1]==0)
zeros <- zip.train[I.0,]
n<-dim(zeros)[1]
n
```

As it is presented here there are $n=1194$ digits corresponding to `ZEROs` in the data set.

The following function (`plot.zip`) generates a plot of the digit, by using the pixel vectors of matrix `x`.

```{r plot.zip.def}
plot.zip <- function(x,use.first=FALSE,...){
  x<-as.numeric(x)
  if (use.first){
    x.mat <- matrix(x,16,16)
  }else{
    x.mat <- matrix(x[-1],16,16)
  }
  image(1:16,1:16,x.mat[,16:1],
        col=gray(seq(1,0,l=12)),...)
  invisible(
    if (!use.first){
      title(x[1])
    }else{
    }
  )  
}
```

Here the three first examples of those ZERO digits are presented.

```{r plot.zero.1to3}
par(mfrow = c(1, 3))
plot.zip(zeros[1, ])
plot.zip(zeros[2, ])
plot.zip(zeros[3, ])
par(mfrow = c(1, 1))
```

## 2. Local MDS for ZERO digits

In this section of the assignment, the `lmds` method from the package `stops` is being used to apply `Local MDS` for **reducing the dimensionality** of the `ZIP dataset`.

### Question a

In order to find a 2-dimensional ($q=2$) configuration of the data using parameters $k=5$ and $τ=0.05$ it is necessary to firstly calculate the distance matrix of the digits dataset, then generate a 2-dimensional configuration using the `cmdscale` method from the package `stats`, and finally apply the `lmds` function of `stops`.

```{r 2d.conf}
D <- dist(zeros[,-1])
k = 5
tau = .05
conf0 <- stats::cmdscale(D,k=2)
lmds.zeros <- lmds(as.matrix(D), ndim = 2, k = k, tau = tau, init = conf0, itmax=1000)
```

Once the 2-dimensional configuration has been computed the generation of its scatterplot can be obtained. It is presented in the following figure:

```{r localMDS.result}
plot(lmds.zeros$conf, asp = 1, main=paste0("Local MDS, k=",k,", tau=",tau), xlab = "dimension 1", ylab = "dimension 2")
```

### Question b

To give an interpretation of the 2 coordinates (`dimension1` and `dimension2`) that were shown in the previous scatter plot and obtained by Local MDS, we follow the idea of selecting `10 points` that cover the variability of the 2-dimensional configuration. The approach that was followed includes the steps described here:

1.  First, we calculate the pairwise distances between all points in the 2-dimensional space generated by Local MDS. These distances are stored in the matrix `D.lmds`, where each element represents the distance between two points.

2.  Then we start by manually selecting two initial points, which are indices `1` and `100`, as the starting points for capturing the variability in the scatterplot. These points represent one of the bottom-left and bottom-right points of the scatter-plot.

3.  Finally, in each iteration of the loop, we calculate the minimum distance between the selected points and all other points in the scatterplot along both dimensions. The `which.max` function is used to find the index of the point that maximizes the minimum distance to the already selected points. This means that we are selecting the point that is farthest from the existing selected points.

Then with the usage of the function `plot.zip` we plot the `ZERO digits` corresponding to the selected points.

```{r select.9.points}
D.lmds <- as.matrix(dist(lmds.zeros$conf))
lmds.points <- c(1, 100)
for (i in seq(1:8)){
  lmds.points <- append(lmds.points, which.max(apply(D.lmds[lmds.points, ], 2, min)))
}
plot(lmds.zeros$conf, asp = 1, main="Result of Local MDS", xlab = "dimension 1", ylab = "dimension 2")
points(lmds.zeros$conf[lmds.points, ], col = 2, pch = 16, asp = 1)
# Add indexes to the points
text(lmds.zeros$conf[lmds.points, 1], lmds.zeros$conf[lmds.points, 2], labels = lmds.points, pos = 3, col = "orange")
legend( x="bottomleft", 
        legend=c("chosen points"),
        col=c("red"), lwd=1, lty=c(NA),
        pch=c(16) )
```

It can be seen that the methodology followed returns `10` points that are located close to the borders of the scatter plot, as well as in its middle, allowing the explainability of the variability of the plot.

To interpret the results, first we go through the `chosen zeros` located on the top (high values of `y` (`dimension2`)) of the scatter-plot **going from lower values of `x` to higher ones**.

```{r dimension1.zeros.top}
# Define the labels of the points you want to plot
selected_labels <- c(106, 1059, 39, 489)

# Set up the plotting grid
par(mfrow = c(1, 4))

# Iterate through the selected labels and plot the corresponding points
for (point in selected_labels){
  # Create the plot
  plot.zip(zeros[point, ])
  
  # Add the index as text in the top right corner of the plot
  text(15, 15, labels = point, col = "red", pos = 1)
}

# Reset the plotting grid
par(mfrow = c(1, 1))
```

In the following plot, *we do exactly the same for the points located on the bottom of the scatter plot* (low values of `y` (`dimension2`)).

```{r dimension1.zeros.bottom}
# Define the labels of the points you want to plot
selected_labels <- c(815, 100, 609, 979, 1, 630)

# Set up the plotting grid
par(mfrow = c(2, 3))

# Iterate through the selected labels and plot the corresponding points
for (point in selected_labels){
  # Create the plot
  plot.zip(zeros[point, ])
  
  # Add the index as text in the top right corner of the plot
  text(15, 15, labels = point, col = "purple", pos = 1)
}

# Reset the plotting grid
par(mfrow = c(1, 1))
```

From the two previous plots, it is clear that the `dimension 1` represents the **width** of the zero digits. More specifically, it can be understood that as the values of `x` in `dimension 1` grow, the width of the zeros get bigger.

Now let's go through the chosen zeros in `dimension 2`. We start by plotting the points in the middle of the scatterplot, starting from low values of `y` (`dimension 2`) following by higher ones.

```{r dimension2.zeros.middle}
# Define the labels of the points you want to plot
selected_labels <- c(609, 979, 1059)

# Set up the plotting grid
par(mfrow = c(1, 3))

# Iterate through the selected labels and plot the corresponding points
for (point in selected_labels){
  # Create the plot
  plot.zip(zeros[point, ])
  
  # Add the index as text in the top right corner of the plot
  text(15, 15, labels = point, col = "blue", pos = 1)
}

# Reset the plotting grid
par(mfrow = c(1, 1))
```

This dimension (`dimension 2`) seems clear to be about the thickness of the zeros. Just to be sure, we plot the `3` selected points located on the far-right side of the scatter plot, again following the same logic.

```{r dimension2.zeros.right}
# Define the labels of the points you want to plot
selected_labels <- c(1, 39, 489)

# Set up the plotting grid
par(mfrow = c(1, 3))

# Iterate through the selected labels and plot the corresponding points
for (point in selected_labels){
  # Create the plot
  plot.zip(zeros[point, ])
  
  # Add the index as text in the top right corner of the plot
  text(15, 15, labels = point, col = "black", pos = 1)
}

# Reset the plotting grid
par(mfrow = c(1, 1))
```

Again, it is clear that we obtain the same result. Meaning, that zeros having lower values for `dimension 2` present a form of lower thickness, while higher values of `dimension 2` represent zeros with high levels of thickness.

### Question c

In this section, the `local continuity meta criteria` is used to select the tuning parameters `k` and `τ` for `Local MDS` applied on the ZERO digits. To begin with, The following function computes the adjusted local continuity Meta-criteria $M_{K'}^{adj}$ as a function of two distance matrices between points (one being computed in the high-dimensional space, an the other being the Euclidean distance matrix in the low-dimensional configuration) and the value $K'$.

```{r}

LCMC <- function(D1,D2,Kp){
  D1 <- as.matrix(D1)
  D2 <- as.matrix(D2)
  n <- dim(D1)[1]
  N.Kp.i <- numeric(n)
  for (i in 1:n){
    N1.i <- sort.int(D1[i,],index.return = TRUE)$ix[1:Kp]
    N2.i <- sort.int(D2[i,],index.return = TRUE)$ix[1:Kp]
    N.Kp.i[i] <- length(intersect(N1.i, N2.i))
  }
  N.Kp<-mean(N.Kp.i)
  M.Kp.adj <- N.Kp/Kp - Kp/(n-1)
  
  return(list(N.Kp.i=N.Kp.i, M.Kp.adj=M.Kp.adj))
}

```

Local MDS depends on `three` tuning parameters:

-   $K$, the number of nearest neighbors used to define the set of nearby pairs $\mathcal{N}_K$.
-   $\tau$, the unit-free parameter used to weight the contribution of large distances in the Local MDS Stress function.
-   $q$, the dimension of the desired low-dimensional configuration.

Here we fix $q=2$.

**In this way we chose the pair** $(K, \tau)$ that maximize the `Local Continuity Meta-criteria`. We use $K'=10$ and restrict the search of $K$ to `c(5,10,50)` and $\tau$ to `c(.1,.5,1)`.

```{r local.continuity.meta.criteria}

K <- c(5,10,50)
tau <- c(.1,.5,1)
Kp <- 10

LC_lmds <- matrix(0,nrow=length(K),ncol=length(tau))
lmds.k.tau <- array(vector("list",1),dim=dim(LC_lmds))

for (i in 1:length(K)){
  for (j in 1:length(tau)){
    lmds.k.tau[[i,j]] <- lmds(as.matrix(D), init=conf0, 
                              ndim=2, k=K[i], tau=tau[j], itmax=1000)$conf
    D.k.tau <- dist(lmds.k.tau[[i,j]])
    LC_lmds[i,j] <- LCMC(D,D.k.tau,Kp)$M.Kp.adj
  }
}

ij.max <- arrayInd(which.max(LC_lmds),.dim=dim(LC_lmds))
k.max <- K[ij.max[1]] 
tau.max <- tau[ij.max[2]] 
lmds.max <- lmds.k.tau[[ij.max[1],ij.max[2]]]

print(paste0("k.max=",k.max,"; tau.max=",tau.max))

```

In the following graphical representation, the low dimensional configuration corresponding to the optimal parameters is presented. Also, we color the points that were selected in the previous question, to check if the dimensions follow the same logic.

```{r plot.local.continuity.meta.criteria}

# Initialize a vector of colors with "lightgray" as the default
point_colors <- rep("lightgray", length(lmds.max[, 1]))

# Update the colors for the specific points
point_colors[c(106, 39, 489)] <- "red"
point_colors[c(815, 100, 1, 630)] <- "purple"
point_colors[c(609, 979, 1059)] <- "blue"
point_colors[c(1)] <- "black"

# Plot the lmds.max
plot(lmds.max, asp = 1, main = "Result of Local MDS with best k and tau", xlab = "dimension 1", ylab = "dimension 2")

# Find the indices of non-"lightgray" labels
non_gray_indices <- which(point_colors != "lightgray")

# Add point indices to the plot with custom colors
text(lmds.max[non_gray_indices, 1], lmds.max[non_gray_indices, 2], labels = non_gray_indices, pos = 3, cex = 0.7, col = point_colors[non_gray_indices])

```

The new `dimension 1` seems to have the same meaning (`red and purple points`). For the new `dimension 2` it can be stated that at some extend the meaning includes the thickness of the digits (`blue points`), however, it is not as clear as before.

## 3. ISOMAP for ZERO digits

### Question a

In this part, a 2-dimensional (`q=2`) configuration of the data needs to be generated, with the usage of the function `ISOMAP` from the package `vegan`. Specifically, the first approach should use the parameter `k` to be equal to $5$. To do so, firstly, it is necessary to calculate the euclidean distance matrix between the vectors of the digits included in the ZIP data set.

```{r isomap.distance}
D.isomap <- as.matrix(isomapdist(dist(zeros[,-1]), ndim = 2, k = 5))
ismp <- isomap(dist(zeros[,-1]), ndim = 2, k = 5)
```

Once the distance has been calculated, the scatter plot of the obtained 2-dimensional configuration is presented. We can observe on the left plot the 2-dimensional configuration, although in the right one, thenet of retained dissimilarities, when $k=5$ is included as well.

```{r isomap.plot}
# Set up the plotting grid
par(mfrow = c(1, 2))
plot(ismp, net=FALSE, main="Output of ISOMAP Algorithm", xlab = "dimension 1", ylab = "dimension 2")
plot(ismp, n.col=2, net=TRUE, main="Output of ISOMAP Algorithm", xlab = "dimension 1", ylab = "dimension 2")
par(mfrow = c(1, 1))

```

### Question b

In this question, the same logic of Exercise 1, question (b) must be followed. The approach used is exactly the same as in the previous section, leading to the selection of `10` points as shown in the next figure.

```{r}
ismp.points <- c(1, 200)
for (i in seq(1:8)){
  ismp.points <- append(ismp.points, which.max(apply(D.isomap[ismp.points, ], 2, min)))
}
plot(summary(ismp)$points, asp = 1)
points(summary(ismp)$points[ismp.points, ], col = 2, pch = 16)
# Add indexes to the points
text(
  x = summary(ismp)$points[ismp.points, 1], 
  y = summary(ismp)$points[ismp.points, 2], 
  labels = ismp.points, 
  col = "orange", pos = 3
)

# Add legend for chosen points
legend( x="bottomleft", 
        legend=c("chosen points"),
        col=c("red"), lwd=1, lty=c(NA),
        pch=c(16) )

```

To interpret the results, first we go through the `chosen zeros` located on the top (high values of `y` (`Dim1`)) of the scatter-plot **going from lower values of `x` to higher ones**.

```{r isomap.dim1.zeros.top}
# Define the labels of the points you want to plot
selected_labels <- c(200, 1, 617)

# Set up the plotting grid
par(mfrow = c(1, 3))

# Iterate through the selected labels and plot the corresponding points
for (point in selected_labels){
  # Create the plot
  plot.zip(zeros[point, ])
  
  # Add the index as text in the top right corner of the plot
  text(15, 15, labels = point, col = "red", pos = 1)
}

# Reset the plotting grid
par(mfrow = c(1, 1))
```

In the following plot, *we do exactly the same for the points located in the bottom of the scatter plot* (low values of `y` (`dimension2`)).

```{r isomap.dim1.zeros.bottom}
# Define the labels of the points you want to plot
selected_labels <- c(918, 280, 439)

# Set up the plotting grid
par(mfrow = c(1, 4))

# Iterate through the selected labels and plot the corresponding points
for (point in selected_labels){
  # Create the plot
  plot.zip(zeros[point, ])
  
  # Add the index as text in the top right corner of the plot
  text(15, 15, labels = point, col = "purple", pos = 1)
}

# Reset the plotting grid
par(mfrow = c(1, 1))
```

In the following plot, *we do exactly the same for the points located in the middle of the scatter plot* (medium values of `y` (`dimension2`)).

```{r isomap.dim1.zeros.middle}
# Define the labels of the points you want to plot
selected_labels <- c(838, 527, 552, 362 )

# Set up the plotting grid
par(mfrow = c(1, 4))

# Iterate through the selected labels and plot the corresponding points
for (point in selected_labels){
  # Create the plot
  plot.zip(zeros[point, ])
  
  # Add the index as text in the top right corner of the plot
  text(15, 15, labels = point, col = "blue", pos = 1)
}

# Reset the plotting grid
par(mfrow = c(1, 1))
```

From the results, it can be understood that `dimension 1` represents the size of the interior "ellipsis" (or in general the width) of the zero digits. More specifically, we can see that as the values of `x` in `dimension 1` grow, the interior "ellipsis" (or the width) of the zeros get bigger. More specifically, it gets wider, and not taller. The only examples when it gets taller is for the points `362` and `439` which is located a little bit higher and way lower, respectively, in the `dimension 2` axis of the scatter plot. This might indicate that `dimension 2` has to do with the height of the digits. Let's figure it out.

To do so, the same logic is followed for `dimension 2`.

```{r isomap.dim2.zeros.middle}
# Define the labels of the points you want to plot
selected_labels <- c(439, 280, 552, 200)

# Set up the plotting grid
par(mfrow = c(1, 4))

# Iterate through the selected labels and plot the corresponding points
for (point in selected_labels){
  # Create the plot
  plot.zip(zeros[point, ])
  
  # Add the index as text in the top right corner of the plot
  text(15, 15, labels = point, col = "black", pos = 1)
}

# Reset the plotting grid
par(mfrow = c(1, 1))
```

In the following plot, *we do exactly the same for the points located in the left of the scatter plot* (medium to low values of `x` (`dimension1`)).

```{r isomap.dim2.zeros.left}
# Define the labels of the points you want to plot
selected_labels <- c(527, 200)

# Set up the plotting grid
par(mfrow = c(1, 2))

# Iterate through the selected labels and plot the corresponding points
for (point in selected_labels){
  # Create the plot
  plot.zip(zeros[point, ])
  
  # Add the index as text in the top right corner of the plot
  text(15, 15, labels = point, col = "black", pos = 1)
}

# Reset the plotting grid
par(mfrow = c(1, 1))
```

By taking a look at the 2-previously generated graphs, we can conclude that `dimension 2` is related with the height of the inner "ellipsis" (or the general height) of the digit. As values of `dimension 2` get higher, the height of the inner "ellipsis" is growing as well (leading to the general increase in the height of the digit).

### Question c

In this question it is necessary to use the `local continuity meta criteria` to select the tuning parameters `k` for `ISOMAP` when applied on the ZERO digits.

\*\*ISOMAP\*\* depends on two tuning parameters:

-   $\varepsilon$ or $k$ that identifies the neighborhood relations:
    -   When using $\varepsilon$, two objects $\mathcal{O}_i$ and $\mathcal{O}_j$ are considered neighbors if $\delta_{ij}=d(\mathcal{O}_i, \mathcal{O}_j)\le \varepsilon$.
    -   When using $k$, two objects $\mathcal{O}_i$ and $\mathcal{O}_j$ are considered neighbors if either $\mathcal{O}_i$ is among the $k$-nearest-neighbors of $\mathcal{O}_j$, or vice-versa.
-   $q$, is the dimension of the desired low-dimensional configuration.

Here we fix $q=2$ and use $k$ instead of $\varepsilon$.

For choosing the parameter $k$ which is maximizing the `Local Continuity Meta-criteria`, we use $K'=10$ and restrict the search of $k$ to c($5$,$10$,$50$).

```{r LCMC.ISOMAP}
K <- c(5,10,50)
Kp <- 10
D1 <- dist(zeros[,-1])
q = 2

LC_isomap <- numeric(length(K))
ISOMAP.k <- vector("list",length(K))

for (i in 1:length(K)){
  ISOMAP.k[[i]] <- isomap(D1, ndim=q, k = K[i])
  D2.k <- dist(ISOMAP.k[[i]]$points[,1:q])
  LC_isomap[i] <- LCMC(D1,D2.k,Kp)$M.Kp.adj
}


i.max <- which.max(LC_isomap)
k.max <- K[i.max]
ISOMAP.max <- ISOMAP.k[[i.max]]
print(paste0("k.max=",k.max))
```
The following illustration presents the values of `LC_isomap` for the different k's.

```{r LC.vs.k}
plot(K, LC_isomap, type="b", main=paste0("k.max=",k.max))
abline(v=k.max,col=2)
```
Finally, the graphical representation of the best `ISOMAP` parametrization ($k=10$) is illustrated below.

```{r best.isomap}
best_ismp <- isomap(D1, ndim = 2, k = 10)
# Define the points you want to label and their corresponding colors
points_to_label <- list(
  red = c(200, 1, 617),
  purple = c(918, 280, 439),
  blue = c(838, 527, 552, 362),
  black = c(439, 280, 552, 527, 200)
)

# Set up the plotting layout
par(mfrow = c(1, 2))

# Plot the ISOMAP without network lines
plot(best_ismp, net = FALSE, main = "Output of Best ISOMAP (k=10)", xlab = "dimension 1", ylab = "dimension 2")

# Add lightgray index labels to all points
#text(best_ismp$points, labels = 1:length(best_ismp$points), col = "lightgray")

# Add colored labels to specific points
for (color in names(points_to_label)) {
  selected_points <- points_to_label[[color]]
  text(best_ismp$points[selected_points, ], labels = selected_points, col = color)
}

# Plot the ISOMAP with network lines
plot(best_ismp, n.col = 2, net = TRUE, main = "Output of Best ISOMAP (k=10)", xlab = "dimension 1", ylab = "dimension 2")

# Add colored labels to specific points
for (color in names(points_to_label)) {
  selected_points <- points_to_label[[color]]
  text(best_ismp$points[selected_points, ], labels = selected_points, col = color)
}

# Reset the plotting layout
par(mfrow = c(1, 1))
```
By taking a look at the best result, and the color of the points, it can be concluded that the best parametrization of the ISOMAP algorithm, retains the same logic for `dimension1` and `dimension2` as it was analysed in question (b) of this section.

## 4. t-SNE for ZERO digits

### Question a
In this part, a 2-dimensional (q=2) configuration of the data needs to be generated, with the usage of the function Rtse from the package Rtse. Specifically, we should use the parameter perplexity to be equal to $40$ and theta equal to $0$.

```{r}
library(Rtsne)

rtsne <- Rtsne(zeros[,-1], dims = 2, perplexity = 40, theta = 0)
plot(rtsne$Y, asp = 1,main="Output of t-SNE Algorithm", xlab = "dimension 1", ylab = "dimension 2")
```

Once the distance has been calculated, the scatter plot of the obtained 2-dimensional configuration is presented.
### Question b

```{r}
D.rtsne <- as.matrix(dist(rtsne$Y))
rtsne.points <- c(1, 100)
for (i in seq(1:8)){
  rtsne.points <- append(rtsne.points, which.max(apply(D.rtsne[rtsne.points, ], 2, min)))
}
plot(rtsne$Y, asp = 1, main="Result of t-SNE", xlab = "dimension 1", ylab = "dimension 2")
points(rtsne$Y[rtsne.points, ], col = 2, pch = 16, asp = 1)

# Add indexes to the points
text(rtsne$Y[rtsne.points, 1], rtsne$Y[rtsne.points, 2], labels = rtsne.points, pos = 3, col = "orange")
```

To interpret the results, we will be choosing and plotting some points based on its values of dimensions.

For example, for dimension 1, we want to compare points with a very similar dimension 2 while dimension 1 changes completely.

Thus, we will take the first 3 top values of y, which will cause the dimension 2 to be fairly similar while we experiment seeing the change of values of dimension 1. Thus, we take points 860, 558 and 100.

```{r}
# Define the labels of the points you want to plot
selected_labels <- c(860, 558, 180)

# Set up the plotting grid
par(mfrow = c(1, 3))

# Iterate through the selected labels and plot the corresponding points
for (point in selected_labels){
  # Create the plot
  plot.zip(zeros[point, ])
  
  # Add the index as text in the top right corner of the plot
  text(15, 15, labels = point, col = "orange", pos = 1, asp=1)
}

# Reset the plotting grid
par(mfrow = c(1, 1))
```


Next, we can take the 4 points in the middle with aprox dimension 2 = 0 +-10, those are points 1, 97, 191 and 282. This will allow us to understand what is the effect of dimension 1, as the values of dim. 1 ranges from almost -40 to 40 on this 4 points, while dim 2 stays practically the same.

```{r}

# Define the labels of the points you want to plot
selected_labels <- c(1, 97, 191 , 282)

# Set up the plotting grid
par(mfrow = c(1, 4))

# Iterate through the selected labels and plot the corresponding points
for (point in selected_labels){
  # Create the plot
  plot.zip(zeros[point, ])
  
  # Add the index as text in the top right corner of the plot
  text(15, 15, labels = point, col = "orange", pos = 1, asp=1)
}

# Reset the plotting grid
par(mfrow = c(1, 1))

```


Finally we will check the lower part of y. With points 1132 and 231.

```{r}
# Define the labels of the points you want to plot
selected_labels <- c(1132,231)

# Set up the plotting grid
par(mfrow = c(1, 2))

# Iterate through the selected labels and plot the corresponding points
for (point in selected_labels){
  # Create the plot
  plot.zip(zeros[point, ])
  
  # Add the index as text in the top right corner of the plot
  text(15, 15, labels = point, col = "orange", pos = 1, asp=1)
}

# Reset the plotting grid
par(mfrow = c(1, 1))

```


It looks like dimension 1 could be about the inner ellipses or the thickness. we can see that the first images on the left side have a smaller thickness and bigger inner ellipses, while on the right side we see a more big thickness in the zero and a smaller ellipse in the middle, it could also be correlated as at the end if the thickness is bigger there is less space in the ellipse in the middle. It is clear thus, that this dimension 1 affects the thickness and the inner space of the zero.

We will do the same now for dimension 2. We look for high variability of dimension 2 while dimension 1 stays more or less the same, thus we will choose the 4 points 100, 558, 282 and 191with dimension 1 equals aprox 25 +-10 and dimension 2 ranging from 40 to -10 aprox.

```{r}
# Define the labels of the points you want to plot
selected_labels <- c(100, 558, 282, 191)

# Set up the plotting grid
par(mfrow = c(1, 4))

# Iterate through the selected labels and plot the corresponding points
for (point in selected_labels){
  # Create the plot
  plot.zip(zeros[point, ])
  
  # Add the index as text in the top right corner of the plot
  text(15, 15, labels = point, col = "orange", pos = 1, asp=1)
}

# Reset the plotting grid
par(mfrow = c(1, 1))
```


Next, we take 4 points in the middle of the x range. The 4 points 860, 97, 416 and 231.

```{r}
# Define the labels of the points you want to plot
selected_labels <- c(860, 97, 416 , 231)

# Set up the plotting grid
par(mfrow = c(1, 4))

# Iterate through the selected labels and plot the corresponding points
for (point in selected_labels){
  # Create the plot
  plot.zip(zeros[point, ])
  
  # Add the index as text in the top right corner of the plot
  text(15, 15, labels = point, col = "orange", pos = 1, asp=1)
}

# Reset the plotting grid
par(mfrow = c(1, 1))

```

Finally, the last points on the lower range of x. The 2 points 1 and 1132.

```{r}
# Define the labels of the points you want to plot
selected_labels <- c(1 , 1132)

# Set up the plotting grid
par(mfrow = c(1, 2))

# Iterate through the selected labels and plot the corresponding points
for (point in selected_labels){
  # Create the plot
  plot.zip(zeros[point, ])
  
  # Add the index as text in the top right corner of the plot
  text(15, 15, labels = point, col = "orange", pos = 1, asp=1)
}

# Reset the plotting grid
par(mfrow = c(1, 1))
```


This dimension seems to be about the size, showing more compact zeros the lower the dimension 2 it was. As values of dimension 2 gets higher, the height of the inner "ellipsis" is growing as well (leading to the general increase in the height of the digit).

### Question c

We proceed to use the local continuity meta criteria to select the tuning parameters perplexity for Rtsne when applied on the ZERO digits.

```{r}
perplexity <- c(10,20,40)
Kp <- 10
D1=dist(zeros[,-1])
LC_tsne <- numeric(length(perplexity))


Rtsne.k <- vector("list",length(perplexity))

for (i in 1:length(perplexity)){
    Rtsne.k[[i]] <- Rtsne(zeros[,-1], perplexity=perplexity[i], dims=2,
                          theta=0, pca=FALSE)
    D2.k <- dist(Rtsne.k[[i]]$Y)
    LC_tsne[i] <- LCMC(D1,D2.k,Kp)$M.Kp.adj
    #print(c(i,j,LC[i,j]))
}
i.max <- which.max(LC_tsne)
perplexity.max <- perplexity[i.max[1]] 
Rtsne.max <- Rtsne.k[[i.max]]
```


The following illustration presents the values of LC_Rtsne for the different perplexities.

```{r}
par(mfrow = c(1, 1))
plot(perplexity,LC_tsne, main=paste0("perplexity.max=",perplexity.max))
abline(v=perplexity[i.max],col=2)
```


Finally, the graphical representation of the best t_SNE parametrization ($perplexity=20$) is illustrated below.


```{r}
# Set up the plotting layout
par(mfrow = c(1, 2))

# Plot the ISOMAP without network lines
plot(Rtsne.max$Y, net = FALSE, main = "Output of Best t-SNE (perplexity=20)", xlab = "dimension 1", ylab = "dimension 2")
# Add indexes to the points
text(Rtsne.max$Y[rtsne.points, 1], Rtsne.max$Y[rtsne.points, 2], labels = rtsne.points, pos = 3, col = "orange")

plot(rtsne$Y, asp = 1, main="Result of t-SNE", xlab = "dimension 1", ylab = "dimension 2")
points(rtsne$Y[rtsne.points, ], col = 2, pch = 16, asp = 1)

# Add indexes to the points
text(rtsne$Y[rtsne.points, 1], rtsne$Y[rtsne.points, 2], labels = rtsne.points, pos = 3, col = "orange")
```


Here we can plot the output of t-SNE algorithm and see the difference compared to our initial version of perplexity=40.

Curiously, we see that the plot seems to be rotated, but the points follow the same structure as before, once you consider that rotation.

Thus, we can still recognize some of the shapes present in both charts, confirming that even though we now know the best model according to LCMC, the dimensions analyzed before with perplexity=40 are not that far to the one we see now, they seem to be a combination of the new dimensions.


## 5. Compare Local MDS, ISOMAP and t-SNE for ZERO digits

### Question a
In this section, the comparison of the best 2-dimensional configurations generated by Local MDS, ISOMAP and t-SNE in the previous sections is taking place. To achieve that the function `pairs` is applied to a 6-dimensional matrix.

```{r 6d.comparison.data}
D1 <- dist(zeros[,-1])
best_ismp <- isomap(D1, ndim = 2, k = 10)
best_lmds <- lmds(as.matrix(D1), ndim = 2, k = 5, tau = 1, init = conf0, itmax=1000)


# Create a data frame with both sets of coordinates
comparison_data <- data.frame(ISOMAP_X = best_ismp$points[, 1], ISOMAP_Y = best_ismp$points[, 2],
                              LMDS_X = best_lmds$conf[, 1], best_lmds$conf[, 2], TSNE_X=Rtsne.max$Y[,1], 
                              TSNE_Y=Rtsne.max$Y[,2])

```


Once the 6-dimension matrix was generated and saved in the previous chunk inside the `comparison_data` dataframe, we can proceed with the generation of the graphical representation for the comparison.

```{r 6d.pairs}
pairs(comparison_data, pch = 1, col = "blue", labels = c("ISOMAP_X", "ISOMAP_Y", "LMDS_X", "LMDS_Y","TSNE_X","TSNE_Y"))

```

As it can be seen from the comparison of the `pairs` plot, it is clear that the `dimension 1` (`X axis`) of `local MDS` and `ISOMAP`, appear a "linear" relationship. As mentioned in the analysis of the respective methods, in the previous sections, for both techniques the `dimension 1` was representing the "width" of the zero digit. Although, as mentioned in `ISOMAP`, it was a little bit more clear that its `dimension1` was focused on the width of the "interior" ellipses of the digit, which was not completely true in `local MDS`. This might be the reason for the slight differences in their linear relation, however they are very much similar. On the other hand, for the `dimension 2` (`Y` axis) between `local MDS`and `ISOMAP` the scatter plot is messy but tends to follow a linear relationship. This indicates that the two axes represent not so different things in the respective approaches. As mentioned in the previous analyses, `dimension 2` for `ISOMAP` is related with the height of the inner "ellipsis" (or the general height) of the digit, while  for `local MDS`, `dimension 2` was clearly representing the thickness of the zeros, thus it makes sense for those two representations to present a similarity. With the same logic we can compare the results of t-SNE with the rest of the models.

### Question b
Lastly, in this section we are presenting the ` local continuity meta criteria` values for the best versions of each respective method (local MDS, ISOMAP, t-SNE).
```{r}
LC_lmds.max <- LC_lmds[which.max(LC_lmds)]
LC_isomap.max <- LC_isomap[which.max(LC_isomap)]
Rtsne.max <- LC_tsne[which.max(LC_tsne)]



max_values <- c(LC_lmds.max, LC_isomap.max, Rtsne.max)
# max_values <- c(LC_lmds.max, LC_isomap.max)
methods <- c("LMDS", "ISOMAP", "tSNE")
# methods <- c("LMDS", "ISOMAP")

# Create a data frame for easy sorting
max_data <- data.frame(Method = methods, Max_Value = max_values)

# Sort the data frame by Max_Value in descending order
max_data <- max_data[order(-max_data$Max_Value), ]

# Print the sorted results with labels
for (i in 1:nrow(max_data)) {
  cat(sprintf("%s: %f\n", max_data$Method[i], max_data$Max_Value[i]))
}

```
From the final result we can conclude that the method produced the highest value for the `Local Continuity Meta-criteria` is `t-SNE.
